{-# LANGUAGE CPP #-}
{-# LANGUAGE ConstraintKinds #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE Rank2Types #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE NoMonomorphismRestriction #-}

module Control.IncComps.CompEngine.Impl (
  CompEngine,
  GenDel,
  garbage,
  startCompEngine,
  stopCompEngine,
  notifyCompEngine,
  stepCompEngine,
  initCompEngine,
  evalWithCompEngine,
)
where

----------------------------------------
-- LOCAL
----------------------------------------

import Control.IncComps.CompEngine.CompFlowRegistry
import Control.IncComps.CompEngine.CompSink
import Control.IncComps.CompEngine.CompSrc
import Control.IncComps.CompEngine.Core
import Control.IncComps.CompEngine.Types
import Control.IncComps.Utils.Logging
import Control.IncComps.Utils.Types

----------------------------------------
-- EXTERNAL
----------------------------------------
import Control.Monad
import Control.Monad.Reader
import Control.Monad.State
import qualified Data.Foldable as F
import qualified Data.HashMap.Strict as HashMap
import qualified Data.HashSet as HashSet
import Data.Map.Strict (Map)
import qualified Data.Map.Strict as Map
import qualified Data.Text as T

newtype CompEngine = CompEngine
  { ce_compEngineIfs :: CompEngineIfs
  }

{- | Track generated outputs and index them by the computation that created them.
 See test_oneComputationRecomputedButOtherUnreferencesIt in TestOutputs
 for why this is necessary.
 Also track unreachable/garbage-collectable caps and outputs.
 Be sure to only delete outputs that have not been generated as well and
 also make sure that there are no stale caps when performing the deletions
 because one of those stale caps might generate the to-be-deleted output.
 See test in TestOutputs for a case where this happens.
-}
data GenDel = GenDel
  { _gd_generated :: Map AnyCompAp AnyCompSinkOutsMap
  , _gd_garbage :: Garbage
  }
  deriving (Show, Eq)

instance Semigroup GenDel where
  (<>) (GenDel a1 b1) (GenDel a2 b2) =
    GenDel (Map.unionWith unionAnyCompSinkOutsMap a1 a2) (b1 <> b2)

instance Monoid GenDel where
  mempty = GenDel mempty mempty

generated :: AnyCompAp -> AnyCompSinkOutsMap -> GenDel
generated k mo = GenDel (Map.singleton k mo) mempty

deleted :: Garbage -> GenDel
deleted = GenDel mempty

garbage :: GenDel -> Garbage
garbage (GenDel gen (Garbage garbage_caps garbage_deps garbage_outputs)) =
  -- First delete any outputs from the generated outputs
  -- that belong to a garbage cap
  let genWithCapsDeleted =
        foldr Map.delete gen (HashSet.toList garbage_caps)
      -- Then remove the resulting set of outputs from any garbage outputs
      result =
        let garbageOutputsRegeneratedFiltered =
              fmap
                ( `diffAnyOutsMap`
                    (unionsAnyCompSinkOutsMap $ Map.elems genWithCapsDeleted)
                )
                garbage_outputs
            garbageOutputsTrimmed =
              HashMap.filter (not . nullAnyOutsMap) garbageOutputsRegeneratedFiltered
         in Garbage garbage_caps garbage_deps garbageOutputsTrimmed
   in if isGarbageEmpty result
        then result
        else pureDebug ("Returning garbage: " ++ show result) result

newtype CompEngineM a = CompEngineM {unCompEngineM :: StateT GenDel (ReaderT CompEngine IO) a}
  deriving (Functor, Applicative, Monad, MonadIO)

{- | Here we remove the cap that generated the garbage from the
 total garbage cap set in the state
 This is necessary to avoid later marking output as garbage
 which might have been regenerated by this cap
 see test_dontDeleteAfterRevival in TestRevive
-}
tellGarbage :: Maybe AnyCompAp -> Garbage -> CompEngineM ()
tellGarbage mKey g =
  CompEngineM $
    do
      let removeCapFromGarbage genDel =
            let appended@(GenDel _ garb@(Garbage gCaps _ _)) =
                  genDel `mappend` deleted g
             in case mKey of
                  Nothing ->
                    appended
                  Just key ->
                    let gCaps' = HashSet.delete key gCaps
                     in appended{_gd_garbage = garb{garbage_caps = gCaps'}}
      modify' removeCapFromGarbage
      let logFun = if mempty == g then logNoLog else logDebug
      logFun ("Collected garbage " ++ show g)

tellOutputs :: AnyCompAp -> AnyCompSinkOutsMap -> CompEngineM ()
tellOutputs key outputs =
  CompEngineM $
    do
      modify' (\genDel -> genDel `mappend` generated key outputs)
      let logFun = if nullAnyOutsMap outputs then logNoLog else logDebug
      logFun ("Outputs generated " ++ show outputs)

runCompEngineM :: CompEngineM a -> CompEngine -> GenDel -> IO (a, GenDel)
runCompEngineM cet ce g = runReaderT (runStateT (unCompEngineM cet) g) ce

runCompEngineM' :: CompEngineM a -> CompEngine -> IO (a, GenDel)
runCompEngineM' cet ce = runCompEngineM cet ce mempty

evalCompEngineM :: CompEngineM a -> CompEngine -> IO a
evalCompEngineM cet env =
  do
    (x, g) <- runCompEngineM' cet env
    when (garbage g /= mempty) $
      fail ("evalCompEngineM produced garbage that would be ignored: " ++ show g)
    return x

initCompAp
  :: CompAp a
  -> CompM a
initCompAp cap@(CompAp _ comp p) = comp_fun comp env
 where
  env =
    CompEnv
      { ce_cachedResult = doAnyRequest $ CompReqCache cap
      , ce_param = p
      , ce_comp = comp
      }

withCompState :: (CompEngineStateIf IO -> IO a) -> CompEngineM a
withCompState mkAction =
  CompEngineM $
    do
      action <- asks (mkAction . ce_stateIf . ce_compEngineIfs)
      lift (lift action)

doCompAp
  :: IsCompResult a
  => CompAp a
  -> CompEngineM (Maybe (CompApResult a))
doCompAp gap =
  do
    withCompState $ \sif -> capEvaluationStarted sif gap
    (deps, res) <- evalCompAp gap
    maybeRes <-
      case res of
        CompResultFail msg -> logNote ("Cap " ++ show gap ++ " failed: " ++ msg) >> return Nothing
        CompResultOk ok ->
          do
            logDebug ("Cap " ++ show gap ++ " succeeded.")
            return (Just ok)
    (staleCaps, gcCaps) <-
      withCompState $ \sif ->
        capEvaluationFinished sif gap deps (fmap cr_returnValue maybeRes)
    tellGarbage (maybeRes >> Just (AnyCompAp gap)) gcCaps
    logStale ("Eval of " ++ show gap) staleCaps
    return maybeRes

evalCompAp
  :: forall a
   . IsCompResult a
  => CompAp a
  -> CompEngineM (DepSet, CompResult (CompApResult a))
evalCompAp outerCap =
  do
    logDebug ("Evaluating " ++ show outerCap)
    result@(_, !ev) <- fmap (fmap (fmap (compApResult outerCap))) $ loop (initCompAp outerCap)
    logDebug
      ( show outerCap
          ++ " --> "
          ++ ( case ev of
                CompResultOk (cr_cacheValue -> ccv) ->
                  concat
                    [ T.unpack (ccm_logrepr (ccv_meta ccv))
                    , " ("
                    , show (ccv_largeHash ccv)
                    , ")"
                    ]
                CompResultFail msg -> msg
             )
      )
    return result
 where
  r =
    case outerCap of
      CompAp _ comp _ -> comp_compMap comp
  doAnyEvalReq
    :: forall a x
     . IsCompResult x
    => CompAp x
    -> CompCont (Maybe (CompApResult x)) a
    -> CompEngineM (DepSet, CompResult a)
  doAnyEvalReq innerCap k =
    evalWithCache False innerCap k (doCompAp innerCap)

  doAnyCacheReq
    :: forall a x
     . IsCompResult x
    => CompAp x
    -> CompCont (Maybe x) a
    -> CompEngineM (DepSet, CompResult a)
  doAnyCacheReq innerCap k =
    evalWithCache True innerCap (k . fmap cr_returnValue) (return Nothing)

  evalWithCache
    :: forall a x
     . IsCompResult x
    => Bool
    -> CompAp x
    -> CompCont (Maybe (CompApResult x)) a
    -> CompEngineM (Maybe (CompApResult x))
    -> CompEngineM (DepSet, CompResult a)
  evalWithCache staleOk cap k f =
    withCompState (flip lookupCapResult cap)
      >>= withCapLookup cap f cont (evalWithCapCached cap f cont staleOk)
   where
    cont
      :: Maybe (CompApResult x)
      -> CompEngineM (DepSet, CompResult a)
    cont x = loop (contToCompM $ k x)

  evalWithCapCached
    :: forall a b
     . IsCompResult a
    => CompAp a
    -> CompEngineM (Maybe (CompApResult a))
    -> (Maybe (CompApResult a) -> CompEngineM b)
    -> Bool
    -> CapResult (CapCached a)
    -> CompEngineM b
  evalWithCapCached cap f cont staleOk capCached =
    case capCached of
      CapSuccess (CapValueCached a)
        | staleOk -> cont (Just a)
        | otherwise ->
            withCompState (flip dequeueGivenCap cap) >>= \case
              True ->
                do
                  logInfo ("Recalculating stale cap now " ++ capName)
                  f >>= cont
              False ->
                do
                  logDebug ("Found valid cached result for " ++ capName ++ ".")
                  cont (Just a)
      CapSuccess (CapMetaCached _meta) ->
        do
          logDebug $ capName ++ " is not cached. Recalculating..."
          f >>= cont
      CapFailure
        | staleOk ->
            do
              logDebug ("Found failed result for " ++ capName ++ ".")
              cont Nothing
        | otherwise ->
            withCompState (flip dequeueGivenCap cap) >>= \case
              True -> do
                logInfo ("Recalculating previously failing, stale cap now " ++ capName)
                f >>= cont
              False ->
                do
                  logDebug ("Found valid cached failure for " ++ capName ++ ".")
                  cont Nothing
   where
    capName = show cap

  withCapLookup
    :: forall a b c
     . IsCompResult a
    => CompAp a
    -> CompEngineM (Maybe (CompApResult a))
    -> (Maybe (CompApResult a) -> CompEngineM c)
    -> (b -> CompEngineM c)
    -> CapLookup b
    -> CompEngineM c
  withCapLookup cap f cont withFound capLookup =
    case capLookup of
      CapFound found -> withFound found
      CapNotFound ->
        --  comp was never evaluated or was removed from cache
        withCompState (flip dequeueGivenCap cap) >>= \isStale ->
          do
            logDebug
              ( (if isStale then "Stale " else "Needed ")
                  ++ show (capId cap)
                  ++ " not cached.  Evaluating!"
              )
            f >>= cont

  doCompSinkReq
    :: forall x a s
     . (CompSink s)
    => TypedCompSinkId s
    -> CompSinkReq s a
    -> CompCont (Fail a) x
    -> CompEngineM (DepSet, CompResult x)
  doCompSinkReq sinkId req cont = do
    let sinkFun sink = do
          (outputs, res) <- liftIO $ compSinkExecute sink req
          return (wrapCompSinkOuts sink outputs, pure res)
    reg <- CompEngineM (asks (ce_compFlowRegistry . ce_compEngineIfs))
    (outputs, action) <-
      withTypedCompSinkId reg sinkId sinkFun >>= \case
        Ok y -> pure y
        Fail reason ->
          let msg = "Refusing to run request for data sink " ++ show sinkId ++ ": " ++ reason
           in pure (emptyAnyCompOutSinksMap, return (Fail msg))
    tellOutputs (AnyCompAp outerCap) outputs
    withCompState (\sif -> trackOutput sif outerCap outputs)
    loop (action >>= contToCompM . cont)

  doCompSrcReq
    :: forall x a s
     . CompSrc s
    => TypedCompSrcId s
    -> CompSrcReq s a
    -> CompCont (Fail a) x
    -> CompEngineM (DepSet, CompResult x)
  doCompSrcReq srcId req cont = do
    let srcFun src = do
          (inputs, res) <- liftIO $ compSrcExecute src req
          let retVal =
                do
                  mapM_ (dependOn . wrapCompSrcDep src) inputs
                  return res
          return retVal
    reg <- CompEngineM (asks (ce_compFlowRegistry . ce_compEngineIfs))
    action <-
      withTypedCompSrcId reg srcId srcFun >>= \case
        Ok x -> pure x
        Fail reason ->
          let msg = "Refusing to run request for data source " ++ show srcId ++ ": " ++ reason
           in pure (return (Fail msg))
    loop (action >>= contToCompM . cont)

  doSuspended
    :: forall x a
     . CompReq a
    -> CompCont a x
    -> CompEngineM (DepSet, CompResult x)
  doSuspended req cont =
    case req of
      CompReqFlow (CompFlowReqSrc src req) -> doCompSrcReq src req cont
      CompReqFlow (CompFlowReqSink sink req) -> doCompSinkReq sink req cont
      CompReqEval compAp -> doAnyEvalReq compAp cont
      CompReqCache compAp -> doAnyCacheReq compAp cont
      CompReqCombined reqA reqB -> do
        -- TODO: Make this bit parrallel
        (wA, resA) <- doSuspended reqA return
        (wB, resB) <- doSuspended reqB return
        let resCont =
              do
                tellDep (wA <> wB)
                res <- (,) <$> compMFinished resA <*> compMFinished resB
                contToCompM (cont res)
        loop resCont

  loop
    :: forall x
     . CompM x
    -> CompEngineM (DepSet, CompResult x)
  loop gen =
    case runCompM gen r of
      (w, CompFinished finalResult) ->
        return (w, finalResult)
      (w, CompSuspended req cont) -> do
        (!w', res) <- doSuspended req cont
        let !w'' = w <> w'
        return (w'', res)

execAp :: AnyCompAp -> CompEngineM ()
execAp (AnyCompAp cap) = void $ doCompAp cap

initCompEngine :: CompEngineIfs -> IO CompEngine
initCompEngine compEngineIfs = return (CompEngine compEngineIfs)

startCompEngine
  :: (F.Foldable t)
  => CompEngineIfs
  -> t AnyCompAp
  -> IO CompEngine
startCompEngine compEngineIfs genAps =
  do
    compEngine <- initCompEngine compEngineIfs
    logNote "Starting CompEngine"
    (_, g) <- runCompEngineM' (F.mapM_ execAp genAps) compEngine
    when (garbage g /= mempty) $
      do
        logError "Garbage generated while starting CompEngine.  This should not happen."
        logError "Not collecting this garbage.  The world is a dirty place:"
    mapM_ (logNote . ("- " ++) . show) (garbage_caps (garbage g))
    mapM_
      (logNote . ("- " ++) . show)
      (fmap (map fst . anyOutsMapToList) $ garbage_outputs $ garbage g)
    logNote "CompEngine started."
    return compEngine

evalWithCompEngine
  :: IsCompResult r
  => CompEngine
  -> CompAp r
  -> IO (Maybe r)
evalWithCompEngine compEngine genAp =
  evalCompEngineM (liftM (fmap cr_returnValue) (doCompAp genAp)) compEngine

notifyCompEngine
  :: CompEngine
  -> [AnyCompSrcDep]
  -> IO EnqueueInfo
notifyCompEngine compEngine reqDeps =
  flip evalCompEngineM compEngine $
    withCompState (\sif -> enqueueStaleCaps sif deps)
 where
  deps = map CompEngDepSrc reqDeps

stepCompEngine
  :: CompEngine
  -> GenDel
  -> IO (Int, GenDel)
  -- ^ approximate number of computations that still need to be run
stepCompEngine compEngine g =
  runCompEngineM action compEngine g
 where
  action =
    do
      mCap <- withCompState dequeueNextCap
      case mCap of
        Just cap ->
          do
            execAp cap
            withCompState staleQueueSize
        Nothing -> return (-1)

stopCompEngine :: CompEngine -> IO ()
stopCompEngine compEngine =
  flip evalCompEngineM compEngine $
    logNote "CompEngine stopped."
